## Types of Databases

Databases are an essential component of many applications, serving as the backbone for data storage and retrieval. There are several types of databases, each designed to serve specific use cases and data management needs. Below is an elaboration on the types of databases:

![[Pasted image 20240830230328.png]]


### **NoSQL Databases**

- `Definition`: NoSQL databases are designed to store, retrieve, and manage large volumes of unstructured or semi-structured data. They are known for their flexibility, scalability, and high performance.
- `Schema-less`: Unlike SQL databases, NoSQL databases do not require a predefined schema, allowing for the storage of data in various formats.
- `Use Cases`: Ideal for big data applications, real-time web apps, and for handling large volumes of data that may not fit neatly into a relational model.

![[Pasted image 20240830230556.png]]

### **Graph Databases**

- `Definition`: Graph databases are designed to store and navigate relationships. They treat the relationships between data as equally important as the data itself.
- `Data Storage`: Data is stored in nodes (entities) and edges (relationships), which makes them highly efficient for traversing and querying complex relationships.
- `Use Cases`: Particularly useful for social networks, recommendation engines, fraud detection, and any domain where relationships are key.

![notion image](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fdd624914-6876-4b58-9694-424f7aa5e22a%2F1115b642-704f-4392-be7f-152702e4ce66%2FUntitled.png?table=block&id=ebeb41f4-c98d-4066-a16e-0b7c9c6dd3de&cache=v2)

### **Vector Databases**

- `Definition`: Vector databases are specialised databases optimised for vector similarity searching. They are used to store and process vector embeddings typically generated by machine learning models.
- `Data Storage`: Data is stored in the form of vectors, which are arrays of numbers that represent data in a high-dimensional space.
- `Use Cases`: Useful in machine learning applications, such as image recognition, natural language processing, and recommendation systems.
-  `Examples`: Pinecone, Milvus, Faiss.

### **SQL Databases**

- `Definition`: SQL databases, also known as relational databases, store data in predefined schemas and tables with rows and columns.
- `Data Storage`: Data is organised into tables, and each row in a table represents a record with a unique identifier called the primary key.
- `Use Cases`: Most full-stack applications use SQL databases for their ability to maintain ACID (Atomicity, Consistency, Isolation, Durability) properties, ensuring reliable transaction processing.

### **Problems with Schema-less Databases**

- `Inconsistent Database`: Without a uniform structure, data can become inconsistent. For example, one document might have a field that others don't, leading to unpredictable query results.
- `Runtime Errors`: Applications may expect certain fields or data types that are not present in all documents, leading to errors at runtime when the code tries to access or manipulate non-existent fields.
- `Too Flexible`: The flexibility that makes NoSQL databases appealing for rapid development can become a liability for applications that require strict data integrity and consistency.

## **Why SQL?**

SQL (Structured Query Language) databases, also known as relational databases, have been the cornerstone of data storage and management in software applications for decades. Their approach to data management offers several advantages, particularly in terms of data integrity, consistency, and reliability. Here's an elaboration on the structured approach of SQL databases and the four key aspects of using them:

#### **1. Strict Schema**

- `Define Your Schema`: Before inserting data into an SQL database, you must define a schema. This schema dictates the structure of the data, including the tables, columns, data types, and relationships between tables.
- `Data Integrity`: By requiring all data to adhere to the predefined schema, SQL databases ensure a high level of data integrity. Each column in a table is designed to hold data of a specific type, and relationships between tables are strictly enforced.
- `Schema Updates and Migrations`: As your application evolves, you may need to update the database schema. This typically involves performing migrations—carefully managed changes that may add, remove, or alter tables and columns without losing data.

#### **2. Running the Database**

- `Database Server`: An SQL database runs on a database server, which can be hosted locally on your development machine, on-premises in your data center, or in the cloud. Running the database involves setting it up, configuring it for performance and security, and ensuring it's accessible for data operations.

#### **3. Connecting and Manipulating Data**

- `Using a Library`: To interact with an SQL database, you typically use a library or an ORM (Object-Relational Mapping) tool that facilitates the connection and allows you to perform data operations in a more abstracted way, often using the programming language of your application.
- `Creating Tables and Defining Schemas`: Before you can store data, you need to create tables and define their schema. This includes specifying the columns, data types, primary keys, foreign keys, and any constraints to enforce data integrity.

#### **Benefits of SQL Databases**

- `Data Integrity and Consistency`: The strict schema and relational model of SQL databases ensure that data is stored in a consistent and reliable manner.
- `ACID Properties`: SQL databases are designed to guarantee ACID (Atomicity, Consistency, Isolation, Durability) properties, making them ideal for applications that require transactions to be processed reliably.
- `Complex Queries`: The SQL language provides powerful querying capabilities, allowing for complex data retrieval that can involve multiple tables and conditions.
- `Mature Ecosystem`: SQL databases have been around for a long time, resulting in a mature ecosystem of tools, libraries, and best practices.



### Understanding Vector Databases 

```js
Harkirat lives in India ⇒ [1, 2, 2, 2, 2,2 ]
Harkirat is from Chandigarh ⇒ [1, 2, 2, 2, 3]
Harkirat has been living in India, Chandigarh ⇒ [1, 2, 2, 2, 2, 3]
The world is round ⇒ [1, 2, 10001, 1001, 001001]
Pacman is such a good game ⇒ [100, 10001, 20020, 1-001, 100]
```

In the above example  `Harkirat` and `India` have similar co-ordinates in both the statements.All the numbers which are getting repeated signify that they have some common or similar words. For example repeated 2 might represent a similar word or a repeated sequence in the data. While identifiers like 10001 might appear to represent certain specific entities.

>Vector databases leverage this property to perform efficient similarity searches. When a query vector is provided, the database can quickly find other vectors with similar coordinates, which correspond to records containing similar words or concepts, thus retrieving relevant information based on semantic similarity.

- Creation of a new client and connecting it.

``` Postgres 

const client = new Client({
  connectionString:
    "postgresql://test_owner:0ndRlBkX1jMo@ep-wispy-boat-a59j5f2r.us-east-2.aws.neon.tech/test?sslmode=require",
});

async function createUserTable() {
  await client.connect();
  const table = await client.query(`
        CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(50) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )`);
  console.log(table);
}

createUserTable();
```

- Data insertion into the table

```Postgres
async function insertData() {
  await client.connect();
  const insertion = await client.query(`INSERT INTO users      (username,email,password) VALUES('connor' ,'priyanshuk@gmail.com','qwerty12345')`);
  console.log(insertion);
}
```

- Data deletion into the table.

```Postgres
deleteResult = await client.query(
  "DELETE FROM users WHERE id = 1;"
);
```

- Data updation into the table

```Postgres
async function updateData() {
  await client.connect();
  const query = `UPDATE  users SET password = $1 WHERE email='abc@gmail.com'`;
  const value = ["qazwsx"];
  const updation = await client.query(query, value);
  console.log(updation);
}
updateData();
```


```typescript
import { Client } from 'pg';

// Async function to fetch user data from the database given an emailasync function getUser(email: string) {
  const client = new Client({
   connectionSting: // something
  });

  try {
    await client.connect();
    const query = 'SELECT * FROM users WHERE email = $1';
    const values = [email];
    const result = await client.query(query, values);

    if (result.rows.length > 0) {
      console.log('User found:', result.rows[0]);
      return result.rows[0];
    } else {
      console.log('No user found with the given email.');
      return null;
    }
  } catch (err) {
    console.error('Error during fetching user:', err);
    throw err;
  } finally {
    await client.end();
  }
}

// Example usagegetUser('user5@example.com').catch(console.error);
```

> Note - To prevent the security threat of SQL injection into the table the user provided strings must be keep separated from the original SQL query as shown in the above examples.




# Prisma

