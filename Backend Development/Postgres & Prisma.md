## Types of Databases

Databases are an essential component of many applications, serving as the backbone for data storage and retrieval. There are several types of databases, each designed to serve specific use cases and data management needs. Below is an elaboration on the types of databases:

![[Pasted image 20240830230328.png]]


### **NoSQL Databases**

- `Definition`: NoSQL databases are designed to store, retrieve, and manage large volumes of unstructured or semi-structured data. They are known for their flexibility, scalability, and high performance.
- `Schema-less`: Unlike SQL databases, NoSQL databases do not require a predefined schema, allowing for the storage of data in various formats.
- `Use Cases`: Ideal for big data applications, real-time web apps, and for handling large volumes of data that may not fit neatly into a relational model.

![[Pasted image 20240830230556.png]]

---
### **Graph Databases**

- `Definition`: Graph databases are designed to store and navigate relationships. They treat the relationships between data as equally important as the data itself.
- `Data Storage`: Data is stored in nodes (entities) and edges (relationships), which makes them highly efficient for traversing and querying complex relationships.
- `Use Cases`: Particularly useful for social networks, recommendation engines, fraud detection, and any domain where relationships are key.

![notion image](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fdd624914-6876-4b58-9694-424f7aa5e22a%2F1115b642-704f-4392-be7f-152702e4ce66%2FUntitled.png?table=block&id=ebeb41f4-c98d-4066-a16e-0b7c9c6dd3de&cache=v2)

---
### **Vector Databases**

- `Definition`: Vector databases are specialised databases optimised for vector similarity searching. They are used to store and process vector embeddings typically generated by machine learning models.
- `Data Storage`: Data is stored in the form of vectors, which are arrays of numbers that represent data in a high-dimensional space.
- `Use Cases`: Useful in machine learning applications, such as image recognition, natural language processing, and recommendation systems.
-  `Examples`: Pinecone, Milvus, Faiss.

---
### **SQL Databases**

- `Definition`: SQL databases, also known as relational databases, store data in predefined schemas and tables with rows and columns.
- `Data Storage`: Data is organised into tables, and each row in a table represents a record with a unique identifier called the primary key.
- `Use Cases`: Most full-stack applications use SQL databases for their ability to maintain ACID (Atomicity, Consistency, Isolation, Durability) properties, ensuring reliable transaction processing.

### **Problems with Schema-less Databases**

- `Inconsistent Database`: Without a uniform structure, data can become inconsistent. For example, one document might have a field that others don't, leading to unpredictable query results.
- `Runtime Errors`: Applications may expect certain fields or data types that are not present in all documents, leading to errors at runtime when the code tries to access or manipulate non-existent fields.
- `Too Flexible`: The flexibility that makes NoSQL databases appealing for rapid development can become a liability for applications that require strict data integrity and consistency.

## **Why SQL?**

SQL (Structured Query Language) databases, also known as relational databases, have been the cornerstone of data storage and management in software applications for decades. Their approach to data management offers several advantages, particularly in terms of data integrity, consistency, and reliability. Here's an elaboration on the structured approach of SQL databases and the four key aspects of using them:

#### **1. Strict Schema**

- `Define Your Schema`: Before inserting data into an SQL database, you must define a schema. This schema dictates the structure of the data, including the tables, columns, data types, and relationships between tables.
- `Data Integrity`: By requiring all data to adhere to the predefined schema, SQL databases ensure a high level of data integrity. Each column in a table is designed to hold data of a specific type, and relationships between tables are strictly enforced.
- `Schema Updates and Migrations`: As your application evolves, you may need to update the database schema. This typically involves performing migrations—carefully managed changes that may add, remove, or alter tables and columns without losing data.

#### **2. Running the Database**

- `Database Server`: An SQL database runs on a database server, which can be hosted locally on your development machine, on-premises in your data center, or in the cloud. Running the database involves setting it up, configuring it for performance and security, and ensuring it's accessible for data operations.

#### **3. Connecting and Manipulating Data**

- `Using a Library`: To interact with an SQL database, you typically use a library or an ORM (Object-Relational Mapping) tool that facilitates the connection and allows you to perform data operations in a more abstracted way, often using the programming language of your application.
- `Creating Tables and Defining Schemas`: Before you can store data, you need to create tables and define their schema. This includes specifying the columns, data types, primary keys, foreign keys, and any constraints to enforce data integrity.

#### **Benefits of SQL Databases**

- `Data Integrity and Consistency`: The strict schema and relational model of SQL databases ensure that data is stored in a consistent and reliable manner.
- `ACID Properties`: SQL databases are designed to guarantee ACID (Atomicity, Consistency, Isolation, Durability) properties, making them ideal for applications that require transactions to be processed reliably.
- `Complex Queries`: The SQL language provides powerful querying capabilities, allowing for complex data retrieval that can involve multiple tables and conditions.
- `Mature Ecosystem`: SQL databases have been around for a long time, resulting in a mature ecosystem of tools, libraries, and best practices.

---

### Understanding Vector Databases 

```js
Harkirat lives in India ⇒ [1, 2, 2, 2, 2,2 ]
Harkirat is from Chandigarh ⇒ [1, 2, 2, 2, 3]
Harkirat has been living in India, Chandigarh ⇒ [1, 2, 2, 2, 2, 3]
The world is round ⇒ [1, 2, 10001, 1001, 001001]
Pacman is such a good game ⇒ [100, 10001, 20020, 1-001, 100]
```

In the above example  `Harkirat` and `India` have similar co-ordinates in both the statements.All the numbers which are getting repeated signify that they have some common or similar words. For example repeated 2 might represent a similar word or a repeated sequence in the data. While identifiers like 10001 might appear to represent certain specific entities.

>Vector databases leverage this property to perform efficient similarity searches. When a query vector is provided, the database can quickly find other vectors with similar coordinates, which correspond to records containing similar words or concepts, thus retrieving relevant information based on semantic similarity.

---

# Postgres

- Creation of a new client and connecting it.

``` sql

const client = new Client({
  connectionString:
    "postgresql://test_owner:0ndRlBkX1jMo@ep-wispy-boat-a59j5f2r.us-east-2.aws.neon.tech/test?sslmode=require",
});

async function createUserTable() {
  await client.connect();
  const table = await client.query(`
        CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(50) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      )`);
  console.log(table);
}

createUserTable();
```

- Data insertion into the table

```sql
async function insertData() {
  await client.connect();
  const insertion = await client.query(`INSERT INTO users      (username,email,password) VALUES('connor' ,'priyanshuk@gmail.com','qwerty12345')`);
  console.log(insertion);
}
```

- Data deletion into the table.

```sql
deleteResult = await client.query(
  "DELETE FROM users WHERE id = 1;"
);
```

- Data updation into the table

```sql
async function updateData() {
  await client.connect();
  const query = `UPDATE  users SET password = $1 WHERE email='abc@gmail.com'`;
  const value = ["qazwsx"];
  const updation = await client.query(query, value);
  console.log(updation);
}
updateData();
```


```typescript
import { Client } from 'pg';

// Async function to fetch user data from the database given an emailasync function getUser(email: string) {
  const client = new Client({
   connectionSting: // something
  });

  try {
    await client.connect();
    const query = 'SELECT * FROM users WHERE email = $1';
    const values = [email];
    const result = await client.query(query, values);

    if (result.rows.length > 0) {
      console.log('User found:', result.rows[0]);
      return result.rows[0];
    } else {
      console.log('No user found with the given email.');
      return null;
    }
  } catch (err) {
    console.error('Error during fetching user:', err);
    throw err;
  } finally {
    await client.end();
  }
}

// Example usagegetUser('user5@example.com').catch(console.error);
```

> Note - To prevent the security threat of SQL injection into the table the user provided strings must be keep separated from the original SQL query as shown in the above examples.

---
# What are ORMs?

ORM stands for Object-Relational Mapping, a programming technique used in software development to convert data between incompatible type systems in object-oriented programming languages. This technique creates a "virtual object database" that can be used from within the programming language.

ORMs are used to abstract the complexities of the underlying database into simpler, more easily managed objects within the code


#### Benefits of ORM

- Simpler syntax (converts objects to SQL queries under the hood)
- Abstraction that lets you flip the database you are using. Unified API irrespective of the DB.

![[Pasted image 20241220141224.png]]

- Type safety/Auto completion
- Automatic migrations
---
# Prisma

#### Initializing a fresh project with Prisma

```bash

npm init -y
npm install prisma typescript ts-node @types/node --save-dev
npx tsc --init
npx prisma init

```

### Defining the Model/Schema 


```Prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         Int      @id @default(autoincrement())
  username   String   @unique
  password   String
  firstName  String
  lastName   String
  todos      Todo[]
}

model Todo {
  id          Int     @id @default(autoincrement())
  title       String
  description String
  done        Boolean @default(false)
  userId      Int
  user        User    @relation(fields: [userId], references: [id])
}
```


#### In this schema:
- The `User` model has a `todos` field, which is an array of `Todo` objects. This represents the "many" side of the one-to-many relationship.
- The `Todo` model has a `userId` field, which stores the reference to the associated `User`. It also has a `user` field that establishes the relationship using the `@relation` attribute. The `fields: [userId]` part specifies which field on the `Todo` model is used to store the connection, and `references: [id]` part specifies which field on the `User` model is being referred to.

---
### Updating the Database and the Prisma Client

After updating the schema, you need to apply the changes to your database and regenerate the Prisma Client to reflect the new relationship:

```bash
npx prisma migrate dev --name relationship
npx prisma generate
```

> The `prisma migrate dev` command creates a new migration file in the `prisma/migrations` folder, which includes the SQL statements necessary to update the database schema with the new relationship. The `prisma generate` command updates the Prisma Client to include the new relationship logic.

---

### Why do you need Prisma Client

The Prisma Client is an auto-generated and type-safe database client that allows developers to interact with their database in a comfortable and secure way. It is part of the Prisma ecosystem, which aims to make database access easy and robust.

---
## Building a Todo Backend

#### Creating a User 

```ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

async function createUser(
  username: string,
  password: string,
  firstName: string,
  lastName: string
) {
  const response = await prisma.user.create({
    data: {
      username,
      password,
      firstName,
      lastName,
    },
  });
  console.log(response);
}

createTodo("ishu1", "qwe", "priyanshu", "kumar");

```

> In this function, `prisma.user.create`  create a new user record.Here the id is the foreign key to the `todo` table. 
#### Creating Todo 

```ts

async function createTodo(userId: number, title: string, description: string) {
  const response = await prisma.todo.create({
    data: {
      title,
      description,
      userId,
    },
  });
  console.log(response);
}

createTodo(1, "go to gym1", "go to gym and do 10 pushups");

```

> In this function, `prisma.todo.create`  is used to create a new Todo record associated with a User by their userId. The data object contains the fields required for the Todo model. 

### Getting Todos for a User in a Single Query

```ts

async function getTodoAndUser(userId: number) {
  const response = await prisma.todo.findMany({
    where: {
      userId: userId,
    },
    select: {
      title: true,
      description: true,
      done: true,
      user: {
        select: {
          username: true,
          password: true,
          firstName: true,
        },
      },
    },
  });
  console.log(response);
}

getTodoAndUser(1);

// Output
[
  {
    title: 'go to gym1',
    description: 'go to gym and do 10 pushups',
    done: false,
    user: { username: 'ishu', password: 'qwe', firstName: 'priyanshu' }
  },
  {
    title: 'go to gym2',
    description: 'go to gym and do 20 pushups',
    done: false,
    user: { username: 'ishu', password: 'qwe', firstName: 'priyanshu' }
  },
  {
    title: 'go to gym1',
    description: 'go to gym and do 10 pushups',
    done: false,
    user: { username: 'ishu', password: 'qwe', firstName: 'priyanshu' }
  }
]

// If no Todos are found for the specific userId an empty array is returned.

```

---




